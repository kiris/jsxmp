// Generated by CoffeeScript 1.4.0
var EsprimaParse, Helper, Parse, Phase, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('underscore');

Helper = require('../helper');

Phase = require('./phase').Phase;

Parse = (function(_super) {

  __extends(Parse, _super);

  function Parse(context) {
    Parse.__super__.constructor.call(this, context, 'parse');
  }

  return Parse;

})(Phase);

EsprimaParse = (function(_super) {

  __extends(EsprimaParse, _super);

  function EsprimaParse() {
    return EsprimaParse.__super__.constructor.apply(this, arguments);
  }

  EsprimaParse.prototype.ESPRIMA_OPTIONS = {
    loc: true,
    comment: true
  };

  EsprimaParse.prototype.preCondition = function() {
    return Helper.assert(this.context.content != null);
  };

  EsprimaParse.prototype.postCondition = function() {
    Helper.assert(this.context.annotations != null);
    return Helper.assert(this.context.errors != null);
  };

  EsprimaParse.prototype.execute = function() {
    var annotations;
    annotations = this.makeAnnotations_(this.context.content);
    return {
      annotations: annotations,
      errors: []
    };
  };

  EsprimaParse.prototype.makeAnnotations_ = function(content) {
    var annotations, body, comments, esprima, lines, _ref,
      _this = this;
    esprima = require('esprima');
    _ref = esprima.parse(content, this.ESPRIMA_OPTIONS), body = _ref.body, comments = _ref.comments;
    lines = content.split('\n');
    annotations = this.collectAnnotations_(comments);
    this.travarse_(body, function(node, path) {
      var annotation, endColumn;
      annotation = _.find(annotations, function(_arg) {
        var line;
        line = _arg.line;
        return (node.loc.start.line - 1 <= line && line <= node.loc.end.line - 1);
      });
      if (annotation == null) {
        return;
      }
      if (node.type !== 'ExpressionStatement') {
        return;
      }
      endColumn = lines[node.loc.end.line - 1][node.loc.end.column - 1] === ';' ? node.loc.end.column - 1 : node.loc.end.column;
      return annotation.body = {
        start: {
          line: node.loc.start.line - 1,
          column: node.loc.start.column
        },
        end: {
          line: node.loc.end.line - 1,
          column: endColumn
        }
      };
    });
    return annotations;
  };

  EsprimaParse.prototype.collectAnnotations_ = function(comments) {
    var regexp;
    regexp = /^ *=>.*$/;
    return comments.filter(function(v) {
      return v.type === 'Line' && regexp.test(v.value);
    }).map(function(v) {
      return {
        line: v.loc.start.line - 1,
        column: v.loc.start.column,
        body: null
      };
    });
  };

  EsprimaParse.prototype.travarse_ = function(node, fn, path) {
    var _this = this;
    if (path == null) {
      path = [];
    }
    if (node instanceof Array) {
      return _.each(node, function(child) {
        return _this.travarse_(child, fn, path);
      });
    } else if (node.type) {
      fn(node, path);
      path = path.concat(node);
      return _.each(node, function(child, key) {
        if (child instanceof Object && (child != null)) {
          return _this.travarse_(child, fn, path);
        }
      });
    }
  };

  return EsprimaParse;

})(Parse);

exports.factory = function(context) {
  return new EsprimaParse(context);
};
